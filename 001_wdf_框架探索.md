[TOC]

WDF由两个框架——umdf和kmdf组成，以支持用户模式和内核模式驱动程序。

尽管这两个框架共享基本的设计原则，但是这两个框架和相关驱动程序的实现细节是完全不同的。

有两个框架可供选择，驱动程序开发人员必须决定使用哪个框架来实现特定设备的驱动程序。

本章讨论了这两个框架是如何实现的，驱动程序如何在每个框架中工作，以及每个框架支持的设备类型，包括为每种设备类型选择最佳解决方案的一些指导原则。



# 框架概览

## UMDF和KMDF的共性

尽管这些框架包含了许多支持UMDF或KMDF驱动程序的特定要求的特性，但两个框架共享的WDF的大多数核心特性:

- 框架提供的对象是驱动程序需要的标准对象的抽象，例如驱动程序对象、设备对象和I/O请求对象。

- 驱动程序通过一致的、设计良好的编程接口访问框架对象。
- 框架管理对象的生存期，跟踪正在使用的对象，并在不再需要它们时释放它们。
- 这些框架实现了一些常见的驱动程序特性，比如用于管理即插即用和电源状态、同步、I/O队列、注册表访问和I/O请求取消的状态机。
- 这些框架管理从Windows到驱动程序产生的I/O请求流，并通过即插即用和电源管理通知协调I/O队列。
- 每个框架在所有支持的Windows版本上一致工作，这样WDF驱动程序就可以运行在一个新的Windows版本上，几乎不需要修改



WDF的一个核心原则是，大多数驱动代码应该致力于管理设备，而不是处理例行的交互与系统，如跟踪即插即用和电源状态。

WDF在驱动程序和Windows之间提供了一个抽象层，以便驱动程序与大多数服务的框架进行交互。这个模型允许WDF为常见操作提供智能的、经过彻底测试的默认功能。

WDF驱动程序根据其设备的需要选择覆盖WDF默认功能，然后允许框架处理其余的操作。开发人员不需要实现大量的“样板”代码来成功地安装和加载驱动程序。

框架在WDF驱动程序和其他驱动程序之间以及WDF驱动程序和Windows之间进行协调交互。WDF驱动程序通过各种框架对象与Windows或其他驱动程序交互，这些框架对象用于诸如处理I/O请求、管理I/O流、同步、内存缓冲区和访问硬件资源(如设备寄存器或中断)等目的.

除了支持所有设备类别使用的特性外，WDF还支持针对特定设备类别的扩展，以支持特定于这些设备类型的特性。例如，UMDF和KMDF都提供了与USB设备通信的扩展。随着新特性被添加到Windows中，并且支持新的设备类别，所有受支持设备类别所共有的特性将被添加到框架的DDI中。

接下来的两个部分将讨论UMDF或KMDF特有的特性。



## UMDF特性

UMDF是一种基于com的编程模型，支持基于协议的即插即用设备(如USB设备)的功能和过滤驱动程序的开发。该框架是一个DLL，它通过提供基于进程内com的驱动程序对象、设备对象、I/O请求对象等来实现WDF对象模型。驱动程序是一个DLL，由一组基于com的进程内回调对象组成，这些对象处理由相关框架对象引发的事件。

选择COM作为UMDF的基础有几个原因:

- COM对于许多程序员来说已经很熟悉了。
- COM接口支持函数的逻辑分组，使DDI易于理解和查找。
- 许多工具，包括ATL，支持基于com的应用程序和对象。



UMDF编程模型基于以下两种类型的对象:

- **Framework objects** 这些对象属于框架，并表示驱动程序本身、驱动程序管理的设备、用于管理I/O请求的I/O队列，等等。

- **Callback objects**  驱动程序实现这些对象并将它们注册到UMDF中。每个对象都为框架对象引发的事件提供特定于设备的响应。

框架提供的对象和驱动程序实现的回调对象的UMDF DDI完全通过COM接口公开。驱动程序使用接口指针而不是对象指针来与框架对象交互。反过来，框架对象通过适当的接口与驱动程序实现的回调对象交互。



### UMDF Framework Objects

在UMDF下，**Framework Objects**可以通过以下方式创建:

- 框架所创建的对象

  例如，当框架加载一个驱动程序时，它创建一个框架驱动程序对象，并传递一个指向驱动程序对象的`IWDFDriver`和`IWDFDeviceInitialize`接口的指针给驱动程序回调对象。

- 驱动程序所创建的对象

  例如，驱动程序通过调用`IWDFDriver:: CreateDevice`来创建一个框架设备对象。

- 一些对象，如I/O请求对象，可以由框架或驱动程序创建，这取决于环境。

框架对象公开的接口名为`IWDFObject`，其中Object引用导出接口的对象。除了`IUnknown`之外，所有框架对象都公开一个或多个接口，这些接口提供对对象功能的访问。例如，框架设备对象还导出`IWDFDevice`和`IWDFObject`。每个接口包含一个或多个用于以下目的的方法:

- 方法指示对象能够执行的操作
- 属性提供可访问的数据

通常每个属性由两个方法组成;调用一个方法读取现有的数据值，调用另一个方法写入新值。不允许对数据进行读写访问的属性只有一个方法。不同的类型通过命名约定来区分。



### UMDF Callback Objects

框架为所有事件提供默认处理。驱动程序可以通过实现回调对象来处理感兴趣的事件，并通过向框架注册对象来覆盖框架的默认事件处理。回调对象公开一个或多个回调接口，每个接口处理一组相关事件。回调接口由一个或多个方法(每个事件一个)组成，框架通过调用来通知驱动程序事件，并向回调对象传递任何相关数据。

驱动程序通过将一个指向对象接口的指针传递给引发相关事件的框架对象来注册回调对象。驱动程序注册回调对象的方式取决于是否驱动程序或框架创建框架对象:

- **Driver-Created框架对象**  驱动程序通常在调用创建框架对象的框架方法时注册回调对象。例如，当驱动程序调用IWDFDriver::CreateDevice来创建框架设备对象时，驱动程序注册它的设备回调对象。
- **Framework-Created框架对象**  由框架创建的对象通常公开一个或多个方法，驱动程序可以调用这些方法来为特定事件注册回调对象。例如，为了为I/O请求注册一个请求完成回调对象，驱动程序调用I/O请求对象的IWDFIoRequest::SetCompletionCallback方法。

驱动程序选择处理的事件决定每个回调对象公开哪些接口。例如，如果驱动程序必须处理队列对象的read事件而不是它的cleanup事件的话，那么回调对象就公开一个回调接口`IQueueCallbackRead`。要处理读取和清理事件，回调对象就同时公开`IQueueCallbackRead`和`IObjectCleanup`。有时一个框架对象不会引发任何事件，所以回调对象是不必要的。例如，驱动程序通常不需要处理内存对象引发的事件。

回调对象不一定仅限于处理单个框架对象引发的事件。例如，Fx2_Driver示例的设备回调对象公开了三个回调接口:`IPnpCallbackHardware`、`IPnpCallback`和`IRequestCallbackRequestCompletion`。前两个在框架设备对象中注册，以处理即插即用和电源管理事件。`IRequestCallbackRequestCompletion`被注册到一个框架队列对象来处理请求完成。



## KMDF 特性

KMDF是一种内核模式编程模型，支持开发过滤器型、功能型或总线型驱动程序。框架本身是一个可重入的库，多个驱动程序可以共享使用。驱动程序在加载时动态地绑定到库。系统可以支持框架的多个并行主版本，每个主版本可以支持多个驱动程序。

框架处理WDM驱动程序的核心任务，并调用相关的KMDF驱动程序(由硬件供应商实现)来提供特定于设备的处理。使用KMDF，您可以开发:

- 即插即用的功能型驱动
- 即插即用的过滤型驱动
- 即插即用的总线型驱动
- 特定类型的微型端口驱动程序，包括NDIS- wdm, NDIS协议，和智能卡
- 非即插即用堆栈的兼容设备的非即插即用驱动程序—类似于传统的Windows NT 4.0风格驱动程序。

驱动程序在构造设备堆栈期间调用框架方法来通知框架驱动程序类型。此外，功能型、过滤器型和总线型驱动程序实现不同的回调函数集。例如，总线驱动程序通常支持枚举总线设备的子设备的回调。功能型驱动程序通常支持回调来管理I/O请求及其设备的电源状态

KMDF DDI支持所有类型的驱动程序。然而，DDI的某些部分是专门用于功能型、过滤器型或总线型驱动程序的。此外，一些KMDF默认功能因驱动程序的类型而不同，特别是I/O请求的默认处理。例如，如果一个过滤器驱动程序不处理一个请求，框架会自动将该请求传递给下一个低级驱动程序。如果一个功能型驱动程序不处理一个请求，框架就会使请求失败。



### KMDF对象

KMDF驱动程序使用回调函数，而不是UMDF使用的回调对象。使用KMDF，框架对象可以通过以下方式创建:

- 框架创建对象并将对象句柄传递给驱动程序。

  例如，当框架收到一个I/O请求时，它创建一个I/O请求对象，并将一个对象句柄传递给驱动程序的`EvtIoXXX`回调例程。

- 驱动程序通过调用框架对象创建方法来创建对象。

  例如，驱动程序通过调用`WdfDeviceCreate`创建一个框架设备对象。

- 有些对象，例如I/O请求对象，是由框架或驱动程序创建的，这取决于环境。

框架对象公开了两种类型的函数:

- 方法指示对象能够执行的操作
- 属性提供可访问的数据

通常每个属性由两个方法组成;调用一个方法读取数据值，调用另一个方法写入新值。不允许对数据进行读写访问的属性只有一个方法。不同的方法通过命名约定加以区分。

>
>
>起初，KMDF的目标是发展驱动模型，使问题随着时间的推移变得更容易。对我来说，有两个特性将框架的目标转向了模型的革命性变化。第一个特性是具体对象模型的定义。对象模型彻底改变了资源的清理和释放，因为它提供了一个关于对象如何彼此交互以及驱动程序本身的清晰契约，将驱动程序从跟踪状态和手动删除对象的需求中解放出来。
>
>第二个特性是引入了用于即插即用、电源和电源策略的状态机。这些状态机对框架中几乎所有对象(尤其是I/O队列、I/O目标和设备)的设计产生了影响。通过将所有状态管理转移到框架中，驱动程序中的代码压缩到在硬件本身上操作，而不是在它周围的操作系统上操作。
>
>与对象模型一样，状态机也定义了一个关于框架和驱动程序应该如何行为的非常清晰的契约。对象模型和状态机一起推动框架从一段时间内采取的一系列小步骤转变为立即采取的巨大飞跃。
>
>-Peter Wieland, Windows Driver Foundation Team, Microsoft



### KMDF回调函数

如果驱动程序必须处理一个框架对象引发的事件，它必须实现一个相应的回调函数并将其注册到框架中。命名回调函数的WDK约定是`EvtObjectEvent`，其中Object引用关联的框架对象，Event引用关联的事件。例如，当设备进入D0电源状态时，框架调用驱动程序的`EvtDeviceD0Entry`回调。然而，这些名称只是文档约定;您可以在KMDF驱动程序中任意命名事件回调函数。



## WDF架构

WDF体系结构的设用于使框架在驱动程序和windows系统之间以及驱动程序和它的设备之间协调大多数交互。本节讨论WDF体系结构，以及主组件如何与驱动程序交互来处理I/O请求和执行其他基本任务。下面两部分将总结如何在UMDF和KMDF驱动程序中实现这种架构。

![1598424901446](001_wdf_%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%B4%A2.assets/1598424901446.png)

**Applications(应用程序)**

应用程序通常与WDF驱动程序交互，就像它们与WDM驱动程序交互一样。应用程序以通常的方式获得设备句柄，并调用适当的Windows API函数向设备发送请求。在大多数情况下，应用程序不知道或者不需要知道它是在与WDM还是WDF驱动程序通信。

> 在UMDF中，我们的主要目标之一就是让应用程序不能区分用户模式和内核模式驱动程序。这是对其他一些特定于设备类的用户模式模型的巨大胜利，这些模型只适用于特定类型的设备，并且在使用驱动程序之前需要对应用程序进行修改。
>
> 我们不能在任何地方都保持透明度。例如，我们允许所有三种I/O控制的传输模式，但是我们不能提供对驱动程序的客户地址空间访问，因此`direct IO` 和`neither IO`某些方面是不可用的。我们添加了一个新的状态码，它可以从I/O操作返回来告诉应用程序驱动进程在处理I/O时终止了。要启用模拟，应用程序必须更改调用CreateFile的方式，以允许驱动程序模拟用户。但是除此之外，从应用程序的角度来看，UMDF驱动程序和KMDF驱动程序是不可区分的。
>
> -Peter Wieland, Windows Driver Foundation Team, Microsoft



这些子系统(i /O管理器、PnP管理器等等)与那些与WDM驱动程序交互的子系统是一样的。从这些子系统的角度来看，框架是一个由WDM设备对象表示的WDM驱动程序。这些服务接收来自应用程序的请求，并使用IRPs将请求传递给框架。当请求完成时，服务将结果返回给应用程序。



**框架的上层**

框架的上层作为windows系统和驱动程序之间的抽象层。通过调用框架DDI，驱动程序可以获得它需要的大多数Windows服务。如果驱动程序需要框架DDI无法提供服务，那么它还可以调用Windows函数。

该框架包括以下三个关键模型，它们管理大多数驱动任务是如何处理的:

- 对象模型控制如何创建和管理框架对象

- I/O模型控制I/O请求的管理方式。

  对于读、写和设备I/O控制请求，框架从Windows接收一个IRP，以对象模型格式重新打包数据，并将其传递给WDF驱动程序进行处理。当驱动程序完成处理后，它将请求返回给框架。当请求完成时，框架完成IRP并将结果返回给I/O管理器，后者最终将结果返回给应用程序。

- I/O模型控制I/O请求的管理方式。

  WDF驱动程序不需要实现一个复杂的状态机来跟踪即插即用和电源状态，并确定当状态改变时要采取的纠正动作。对于即插即用和电源管理请求，框架状态机根据接收到的特定即插即用或电源IRP和当前系统状态确定需要什么操作。该模型包含一组直接映射到特定于设备的操作的事件。驱动程序仅为那些对其设备重要的事件注册回调，并让框架处理其余的事件。



**框架对象**

框架对象是WDF驱动程序的基本构建块。它们表示常见的驱动程序，如设备、内存、I/O队列等。驱动程序通过定义良好的接口与对象交互。这些对象要么由框架创建并传递给驱动程序，要么由驱动程序通过使用框架公开的方法创建。



**驱动回调函数**

对于感兴趣的事件，驱动程序会覆盖框架的默认处理函数，并提供它们自己的事件处理函数。为了覆盖框架对事件的默认处理，驱动程序实现并注册一个回调。当事件发生时，框架调用回调并将任何相关数据传递给驱动程序。驱动程序处理事件并将结果返回给框架。

> **何时实现回调** 我总是喜欢说，WDF的默认事件处理方式将为你提供一个完全独立的功能驱动程序。如果你想让驱动程序做一些有趣的事情，你只需要重写默认行为。
>
> -Peter Wieland, Windows Driver Foundation Team, Microsoft



**框架的下层**

驱动程序经常与他们的设备或其他驱动程序通信，例如:

- 为了与另一个驱动程序通信，WDF驱动程序使用一个称为I/O目标对象的框架对象。

  框架处理向其他驱动程序传递请求并将任何结果返回给WDF驱动程序的机制。

- KMDF驱动程序使用框架的DMA对象来管理与支持DMA的设备之间的数据传输。

UMDF驱动程序不直接与设备通信。相反，框架将请求传递给相关的内核模式驱动程序，后者处理数据传输。





## UMDF接口

从Windows I/O管理器的角度来看，I/O请求的目标必须是WDM设备对象。这些对象驻留在内核模式地址空间中，用户模式驱动程序无法访问这些对象。UMDF的一个关键需求是用一种安全的方式在用户模式和内核模式之间架起一座桥梁，并将I/O请求交付给用户模式驱动程序。这一要求由以下UMDF基础设施的主要组成部分来处理:

- 内核模式驱动程序(称为反射程序)，它在设备堆栈的内核模式部分表示UMDF驱动程序。反射器管理与UMDF主机进程之间的通信，该进程在用户模式下运行。
- 一种通信机制，允许请求通过用户模式/内核模式边界发送到主机进程并返回。

![1598426089130](001_wdf_%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%B4%A2.assets/1598426089130.png)



### UMDF基础组件

每个UMDF驱动程序作为管理设备的操作设备堆栈的一部分。部分堆栈运行在用户模式,部分堆栈运行在内核模式，如下:

- 堆栈的上部以用户模式运行

  它由加载驱动程序和框架dll的主机进程`wudfhosts`组成。宿主进程还帮助管理UMDF堆栈中驱动程序之间的通信，以及堆栈的内核模式和用户模式组件之间的通信。

- 堆栈的上部以内核模式运行

  它处理与内核子系统和设备的实际交互。在某些情况下，如USB驱动程序，微软提供较低的设备堆栈。在其他情况下，硬件供应商实现较低的设备堆栈。

> 对于一些UMDF驱动程序，设备堆栈的内核模式部分的唯一目的是将设备添加到PnP管理器的设备树中。此类驱动程序的例子包括纯软件驱动程序和使用Windows API与设备通信的网络连接设备的驱动程序。



#### **UMDF Host Process (UMDF宿主进程)**

Wudfhost承载组成设备堆栈的用户模式部分的组件，并协调这些组件与反射器之间的通信。每个UMDF堆栈都有自己的主机进程。以下是主体托管组件:

- **UMDF栈** 这个栈由一个或多个功能型或过滤型驱动程序组成。UMDF栈有它自己的设备对象和I/O请求包，它们与底层的WDM数据结构相关。UMDF栈处理I/O请求的方式与内核模式栈非常相似，尽管实现细节不同。
- **框架的一个或多个实例**  栈中的每个UMDF驱动程序都有一个框架实例。这个框架是一个库，它支持UMDF对象模型，并在驱动程序和主机进程之间协调通信。

Wudfhost是驱动程序管理器进程的子进程。尽管它不是Windows服务，但Wudfhost使用LocalService帐户的安全凭据运行

> **WDF, UMDF, and WUDF**
>
> 有时我们使用WUDF作为缩写，有时我们使用UMDF，然后有时KMDF就是WDF。这是KMDF和UMDF项目开始时的一个不幸的副作用。最初只有“WDF”——Windows驱动程序框架。然后，Windows用户模式驱动程序框架出现了。有一段时间还出现了Windows内核模式驱动框架。最后，我们决定使用KMDF和UMDF，但到那时，较早的首字母缩略词已经被固定在代码库中了
>
> -Peter Wieland, Windows Driver Foundation Team, Microsoft



####  **The Driver Manager(驱动管理器)**

驱动程序管理器是一个管理系统上所有UMDF主机进程的Windows服务。它创建主机进程，在主机进程运行时维护状态信息，并在不再需要主机进程时关闭主机进程。在安装第一个UMDF驱动程序之前，驱动程序管理器是禁用的



####  **The Reflector(反射器)**

反射器是一个内核模式驱动程序，支持系统上的所有UMDF驱动程序。它管理内核模式组件(如内核模式设备栈和UMDF主机进程)之间的通信。反射器为系统上的每个UMDF设备堆栈创建以下两个设备对象:

- **向上的设备对象** 此对象安装在设备的内核模式设备堆栈的顶部。它接收来自I/O管理器的请求，将它们传递给UMDF主机进程进行处理，并在它们完成后返回给I/O管理器。
- **向下的设备对象** 这个对象是一个没有安装在内核模式设备堆栈中的“边缘对象”。在驱动程序处理了请求之后，它从UMDF主机进程接收I/O请求。向下的设备对象将它们传递到较低的设备堆栈，后者处理与设备的通信。为了创建设备接口或模拟客户端等目的，主机进程还与停机设备对象通信。

反射器还创建另一个端对象—一个控制设备对象(服务于系统上的所有UMDF主机进程)。控制设备对象处理反射器和与I/O请求无关的UMDF主机进程之间的通信，例如管理主机进程的创建或关闭。

> **为什么使用边缘对象?**
>
> 有几个简单的例子可以帮助解释这一点。当启动设备堆栈时，我们需要UMDF驱动程序能够向较低的设备堆栈发送I/O请求。我们不能与较低的设备堆栈本身对话，因为I/O管理器不允许您在设备堆栈启动之前打开它。
>
> 设备删除也会出现类似的问题。PnP管理器不会向设备栈发出删除请求，直到设备栈的最后一个句柄被关闭。但如果我们关闭那个句柄，用户模式驱动程序就无法在移除过程中向设备发送命令。
>
> 我们本可以构建一个内部接口，让我们尽早发送I/O请求，但这不能与ReadFile和WriteFile一起工作，而且会造成兼容性问题。
>
> 边缘对象很优雅地解决了这个问题。因为它不在设备堆栈中，我们可以随时打开它。反射器阻止了来自非主机进程的任何I/O，因此没有其他人可以打开或使用边缘对象，而驱动程序可以在启动期间使用相同的api访问对象，并在其他任何时候删除它。
>
> -Peter Wieland, Windows Driver Foundation Team, Microsoft





#### **The Lower Device Stack(底层设备栈)**

UMDF驱动程序最终依赖于一个底层的内核模式设备堆栈来处理与设备的实际通信。在USB驱动程序等情况下，UMDF驱动程序可以使用微软的内核模式设备堆栈。否则，硬件供应商必须提供较低的驱动程序。



### UMDF驱动中产生的致命错误

当框架因为一个致命错误而停止一个驱动程序时，它只终止驱动程序主机进程;其他进程和系统本身可以继续。以用户模式运行的一个很大的好处是，驱动程序只能访问它自己的地址空间，而不是内核地址空间。因此，致命的驱动程序错误不会影响内核内存，所以它只会崩溃驱动程序进程，而不是整个系统。

当UMDF驱动程序失败时，反射器会以错误状态完成任何未完成的I/O请求，并向任何已注册接收此类通知的应用程序发送通知。Windows记录了这个失败并尝试重新启动五次这个设备实例。如果设备不能重新启动，系统将禁用该设备，如果设备堆栈中没有打开任何设备对象的句柄，则卸载设备堆栈中相关的内核驱动程序。



### 典型的UMDF I/O请求

应用程序通过使用设备接口来获取设备的符号链接名，然后调用CreateFile来获取设备句柄，从而打开与UMDF驱动程序的通信。应用程序使用句柄向驱动程序发送I/O请求。应用程序通常不知道它正在使用usermode驱动程序，因为获取设备句柄和向设备发送I/O请求的过程对于UMDF驱动程序和内核模式驱动程序的工作方式是完全相同的。

一个典型的UMDF I/O请求，如读取或设备I/O控制请求，采取以下路径:

1. 一个应用程序调用一个Windows功能，如ReadFile或DeviceIoControl发送一个I/O请求到设备。Windows调用适当的内核模式I/O例程，该例程将请求传递给I/O管理器。
2. I/O管理器创建一个IRP并将其发送给反射器的`向上设备对象`，该对象将请求传递给驱动程序的主机进程。主机进程创建一个“用户模式IRP”来表示设备堆栈的用户模式部分的IRP。
3. 主机进程将用户模式IRP传递给设备堆栈中框架的顶部实例。
4. 框架使用来自用户模式IRP的数据来创建一个框架I/O请求对象，并将其传递给适当的驱动程序回调对象。
5. 驱动程序处理I/O请求并将其发送到驱动程序的默认I/O目标，通常是堆栈中下一个较低的驱动程序。这个动作将请求传递回框架，框架要求主机进程将请求发送给下一个驱动程序。框架还存储了一个指向请求对象的指针，这允许框架稍后确定驱动程序是否注册了一个请求完成回调。
6. 如果堆栈有额外的UMDF驱动程序，步骤3、4和5对每个UMDF驱动程序重复，直到请求到达一个可以完成请求的驱动程序。
7. 主机进程将处理后的请求发送到反射器的`向下设备对象`，该对象创建第二个IRP。
8. `向下的设备对象`将请求传递给较低的设备堆栈，后者处理请求并根据需要与设备通信。最后，底层设备堆栈中的一个驱动程序完成第二个IRP。
9. `向下的设备对象`将完成的I/O请求返回到驱动程序的主机进程。如果任何UMDF驱动程序已经注册了请求完成回调，框架将从堆栈的底部开始按顺序调用它们。
10. 在完成所有UMDF驱动程序的完成回调之后，框架将完成的I/O请求传递给反射器的`向上的设备对象`，并释放用户模式的IRP。`向上的设备对象`将请求传递回I/O管理器，后者将请求的结果返回给应用程序。



## KMDF接口

KMDF作为WDM上的一个抽象层运行。因为框架和相关的驱动程序都在内核模式下运行，所以接口比UMDF简单得多。图4-3显示了组成KMDF基础设施的组件。作为一个例子，图中显示了一个简单的设备堆栈，由一个KMDF函数驱动程序，一个WDM低过滤器驱动程序，和一个WDM总线驱动程序组成。

![1598427797327](001_wdf_%E6%A1%86%E6%9E%B6%E6%8E%A2%E7%B4%A2.assets/1598427797327.png)





## KMDF接口组件

KMDF接口组件由几个组件组成:框架、KMDF驱动程序和其他驱动程序。

#### 框架

与组成UMDF接口框架的多个运行时组件相比，KMDF只有一个运行时组件(框架)。框架的一个实例支持系统上的所有KMDF驱动程序。如果系统安装了框架的多个主版本，那么每个主版本都有一个实例来支持为该版本编译的驱动程序。

每个KMDF驱动程序调用框架来为驱动程序支持的每个设备创建框架设备对象。框架依次创建相应的WDM设备对象，并将其安装到设备堆栈中。如果KMDF驱动程序是一个功能型驱动程序，那么框架将创建一个FDO并将其安装在较低的过滤器驱动程序之上，以此类推。因为KMDF驱动程序的上边缘和下边缘作为一个WDM驱动程序操作，因此设备堆栈可能包括KMDF和WDM驱动程序的混合物。

当属于框架的设备对象接收到来自I/O管理器的IRP时，框架与相关的KMDF驱动程序交互以处理请求。如果KMDF驱动程序没有完成请求，框架将IRP传递回I/O管理器，以传递给堆栈中的下一个较低的驱动程序，依此类推。除了管理IRP流之外，框架还支持KMDF DDI和对象模型，驱动程序使用它们与框架、其他驱动程序和设备交互。该框架还跟踪系统和设备状态，并为即插即用和电源管理请求提供默认处理。



#### KMDF驱动程序

KMDF模型在某种程度上类似于port-miniport模型，框架充当端口驱动程序，KMDF驱动程序充当一个miniport驱动程序。框架的设备对象安装在设备堆栈中，框架处理驱动程序的许多功能。但是，该框架依赖于相关的KMDF驱动程序来进行特定于设备的处理。有一个主要的区别之间的端口-微型端口模型和KMDF;KMDF不限制驱动程序可以调用的DDI例程或驱动程序如何操作。



#### 其他驱动程序

设备堆栈可以由多个驱动程序组成，其中任何一个或全部都可以是KMDF驱动程序。图4-3中的例子显示了安装在WDM较低过滤驱动程序上的KMDF功能驱动程序。然而，它也可以是两个KMDF驱动程序或一个WDM功能型驱动程序以及一个KMDF较低的过滤器驱动程序。irp像往常一样在堆栈中移动，当irp到达一个kmdf相关的设备对象时，框架创建相应的框架请求对象。





### 在KMDF框架中产生的致命错误

当框架因为一个致命错误而停止一个驱动程序时，系统已经无法恢复，所以框架生成一个错误检查并崩溃系统。所有框架bug检查都使用代`WDF_VIOLATION`，,它有四个参数。第一个参数表示特定类型的错误，其他参数提供关于错误的更多信息。





### 典型的KMDF I/O请求

应用程序通过使用设备接口来获取设备的符号链接名，并调用CreateFile来获取设备句柄，从而打开与KMDF驱动程序的通信，就像应用程序对其他类型的驱动程序所做的那样。典型的I/O请求采用以下路径:

1. 一个应用程序调用一个Windows函数，如ReadFile或WriteFile发送一个I/O请求到设备。Windows调用适当的内核模式I/O例程，该例程将请求传递给I/O管理器。
2. I/O管理器创建一个IRP并将其发送到设备堆栈的顶部。在本例中，与KMDF驱动程序关联的FDO位于顶部，因此它接收请求。
3. 如果FDO处理这种类型的IRP，框架会将IRP转换为框架请求对象。框架将请求对象传递给KMDF驱动程序。
4. 驱动程序处理请求并将结果返回给框架。如果驱动程序完成或失败了，框架将完成IRP并将结果返回给I/O管理器。否则，框架将格式化IRP并将其传递给下一个较低的驱动程序进行进一步处理。如果KMDF驱动程序必须在请求完成后做任何最后的处理，驱动程序在框架中注册一个I/O完成回调，框架会在IRP中设置一个I/O完成例程。
5. 如果KMDF驱动程序将请求向下传递到堆栈以进行进一步处理，框架将根据需要格式化IRP并将其返回给I/O管理器。I/O管理器将IRP传递给WDM较低的过滤器驱动程序，后者处理请求，等等。
6. 当请求最终完成时，如果KMDF驱动程序注册了一个I/O完成回调，I/O管理器调用框架设置的I/O完成例程。框架反过来调用驱动程序的I/O完成回调，以便驱动程序可以完成它的处理。



## WDF对设备和驱动程序的支持

选择为设备使用哪种框架——umdf还是kmdf——主要取决于设备的类型。本节将讨论这两种框架支持哪种类型的设备，以及在选择框架时应该考虑的问题。



### 由UMDF支持的设备

UMDF支持基于协议或基于串行总线设备的驱动程序的开发，例如USB设备。UMDF可用于分别为32位和64位设备实现运行在x86或x64版本的Windows上的驱动程序。一些例子包括:

- 便携式设备，如pda、移动电话和媒体播放器。
- USB设备，同步设备除外。
- 辅助显示和视频设备。

设备可以直接连接、通过网络连接或通过蓝牙等无线技术连接。UMDF也可以用来实现纯软件驱动程序。

> **32位和64位UMDF驱动**
>
> 经常有人问我们UMDF是否允许开发人员在64位系统上运行32位驱动程序。WDM或KMDF驱动程序不允许这样做，因为您不能在64位内核中运行32位代码。但是，由于您可以在64位系统上运行32位应用程序，这个问题似乎总是会出现。这是不可能的。
>
> 虽然UMDF可以运行32位驱动程序代码，但它无法知道如何处理来自64位应用程序的请求。正如64位内核模式驱动程序通常需要特殊代码来处理来自32位应用程序的I/O控制请求一样，64位机器上的32位驱动程序也需要能够从64位应用程序进行特殊情况调用。UMDF不能让请求通过，因为这可能会导致缓冲区溢出或其他安全缺陷。在我看来，这并不是什么大损失。驱动程序已经被重写以运行在用户模式，所以为什么不编译它为64位，而且因为32位和64位应用程序有一些细微的行为差异，您仍然希望在64位系统上测试您的驱动程序。因此，为什么不直接构建并测试64位驱动程序呢?
>
> -Peter Wieland, Windows Driver Foundation Team, Microsoft



### UMDF驱动程序的优点

#### 驱动环境

UMDF驱动程序运行在一个比内核模式驱动程序运行的环境简单得多的环境中。例如，内核模式驱动程序必须编码以避免与IRQL、页面错误和线程上下文相关的问题。然而，在用户模式下，这些问题并不存在。UMDF驱动程序总是可以处理页面错误。此外，UMDF驱动程序总是运行在一个地址空间中，这个地址空间与请求进程的地址空间是分开的。



#### 提高系统稳定性

与内核模式驱动程序不同，UMDF驱动程序运行的环境与系统的其他部分是隔离的。特别是，每个UMDF驱动程序运行在它自己的地址空间中，其他驱动程序不能覆盖或破坏它。损坏或错误的UMDF驱动程序可能导致设备无法操作，但是与内核模式驱动程序相比，UMDF驱动程序不太可能导致系统范围的问题。特别是，UMDF驱动程序不会导致错误检查(蓝屏)，因为它们不能访问内核地址空间，也不能调用操作重要的系统数据结构所需的内核模式函数。



#### 减少安全风险

UMDF驱动程序通常在`LocalService`帐户中运行，该帐户只提供有限的特权。事实上，UMDF驱动程序通常使用低权限运行，这使得UMDF驱动程序是相对没有吸引力的安全攻击目标，因为一个受损的UMDF驱动程序只能有限地访问系统资源。如果攻击者确实破坏了UMDF驱动程序，唯一面临的风险是流经驱动程序的用户数据数据。此外，UMDF驱动程序不太可能通过挂起或崩溃系统而导致拒绝服务攻击。在最坏的情况下，驱动进程本身可能被损坏，但是可以在不影响其他进程的情况下终止它。

> **UMDF驱动程序可以支持模拟，但是驱动程序必须注册这个功能，当它被安装和被授予许可模拟用户的应用程序发出请求。尽管这些因素限制了风险，支持模拟的UMDF驱动程序仍然必须小心。如果驱动程序被破坏，注入的代码可以等待，直到驱动程序收到来自管理员的允许模拟的请求。此时，驱动程序可以冒充管理员并攻击系统。**



#### Windows API

大多数应用程序程序员都熟悉Windows API。UMDF驱动程序不能调用内核函数，但是它们可以调用大部分Windows API，这些API提供对内核模式中不可用的服务的访问，比如加密。然而，UMDF驱动程序进程运行在一个不允许用户交互的会话中，因此驱动程序不能使用Windows API中支持用户界面的那些部分。因为Windows API是一个用户模式组件，所以在用户模式调用者请求更改之前，Windows会执行额外的安全性和验证检查。

在调用外部进程或组件时，仍然必须小心。例如，如果您将一个被破坏的COM对象作为进程内组件加载到您的驱动程序中，您就创建了一个安全漏洞。Windows API也可能不适合在异步I/O模型中使用。例如，不能取消的长时间运行的同步操作可能会迫使驱动程序同步地处理它的请求，从而限制驱动程序的性能。

> 不要试图让你的驱动程序建立一个UI。因为驱动程序在用户模式下运行并不意味着你可以使用它来显示UI元素。UMDF驱动程序与其他系统服务一起在“会话0”中运行，并且没有桌面。这不仅意味着用户不能看到你的任何UI元素，也意味着你可以挂起你的驱动程序，不能使用任何UI阻塞等待用户输入，因为用户不能提供任何输入。如果你想提供UI，那么你应该构建一个独立的接口组件，通过标准的Windows I/O调用与你的驱动通信。



#### 用户模式调试

可以使用用户模式调试器而不是内核模式调试器来调试UMDF驱动程序。在用户模式下调试可以使驱动程序开发变得更快，因为一个错误只影响当前进程，而不是整个系统。这减少了在内核模式驱动程序中的错误导致系统崩溃后重新启动所花费的时间。此外，UMDF调试只需要一台计算机，而内核模式调试通常需要两台计算机:一台用于调试器的主机和一台用于驱动程序的目标计算机。



#### 使用C/C++编程

由于UMDF是基于COM的，所以可以很容易地用c++实现。也可以在C语言中实现UMDF驱动程序，尽管这不是经常做的。



#### 与内核模式的性能相当

对于UMDF驱动程序可以支持的设备类型，速率限制因素通常是I/O带宽，而不是内部驱动程序性能。对于这样的设备，UMDF驱动程序的性能相当于等效的KMDF驱动程序。



### UMDF驱动程序的限制

虽然以用户模式运行有很多优点，但是不能访问内核模式地址空间会带来一定的限制。有些驱动程序根本不能在用户模式下运行，也不能实现为UMDF驱动程序。驱动程序必须写为内核模式的驱动程序，如果他们需要任何以下功能和资源:

- 直接访问硬件，包括处理中断的能力。
- 不间断的时间循环。
- 访问内核数据结构或内核内存。

此外，UMDF驱动程序不能是Windows内核或内核模式驱动程序的客户端。



## KMDF支持的设备

KMDF被设计用来替代WDM，因此它可以被用来开发与WDM相同的设备和设备类的驱动程序。例外是一些迷你端口模型支持的设备类，比如Storport驱动程序。

一般来说，一个符合WDM的驱动程序，为主要的I/O分派例程提供入口点，并处理IRPs，也可以作为KMDF驱动程序实现。对于某些设备类型，设备类驱动程序和端口驱动程序提供驱动程序分派函数并回调到一个迷你端口驱动程序——本质上是一个特定于设备的回调库——来处理特定的I/O细节。WDK的Windows服务器“Longhorn”版本所包含的框架版本不支持使用Windows映像获取(WIA)体系结构的大多数迷你端口驱动程序或设备类型。

> **KMDF和WDM**
>
> 框架作为一个具有上下WDM接口的WDM设备对象出现，这一事实使KMDF成为一个通用的解决方案，可以与各种设备堆栈一起工作。这就是KMDF在兼容性和对多个设备类的适用性方面的真正强大之处。
>
> 另一方面，这种能力也是KMDF开发和测试团队最大的负担之一。框架实现的抽象和对象必须与多个已经发布的设备类兼容，这些设备类不能更改来匹配新的框架行为。为了确保全面的兼容性，需要对外部接口进行大量的测试和设计(比如与power相关的回调)。





### 选择正确的框架

虽然选择一个框架看起来是一个重大的决定，但它实际上很简单。如果您可以为您的设备编写一个UMDF驱动程序，那么就这样做。你将节省开发和调试的时间，你的驱动程序将更加安全和稳定。只在必要时编写内核模式驱动程序。对于大多数设备类型，决定很简单。例如:

- 一个MP3播放器可以有一个UMDF驱动程序，因为该播放器使用Windows便携设备模型
- 典型的网络适配器处理中断并执行DMA，因此它必须使用KMDF驱动程序。

两种框架都支持一些设备类型(最重要的是USB设备)。大多数USB设备可以支持UMDF驱动程序。但是，如果驱动程序必须使用仅对KMDF可用的服务，则必须实现KMDF驱动程序。

KMDF和UMDF都不支持文件系统驱动程序或文件系统过滤驱动程序的开发。要开发文件系统驱动程序，必须使用随WDK提供的可安装文件系统工具包。

